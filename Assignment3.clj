"Write a function called sdsu-rotate which can rotate a sequence in either direction. The
function can return a collection type of your choice."

(defn sdsu-rotate
  [c l]
  (loop [counts c list l]
    (if (>= counts 0)
      (if (> counts 0)
        (recur (dec counts) (concat (rest list) (take 1 list)))
        list)
      (recur (inc counts) (concat (take-last 1 list) (drop-last 1 list))))))







"If we list all the positive integers below 10 that are multiples of 2 or 5, we get 2, 4, 6, 8, 5.
The sum of these multiples is 25. Write a function sdsu-sum that takes three arguments.
The first two arguments are the numbers we will take the multiples of. The third argument
the the number we want the multiples to be less than. Sdsu-sum returns the sum of the
multiples of the two numbers less than the third argument."

(defn sum
  [first second number start sum]
  (loop [f first s second n number st start sm sum]
    (if (< st n)
      (if (or (= (rem st f) 0) (= (rem st s) 0))
        (recur f s n (inc st) (+ sm st))
        (recur f s n (inc st) sm))
      sm)))


(defn sdsu-sum
  [f s n]
    (sum f s n 1 0))







"A palindromic integer is an integer that reads the same both ways. For example, 101, 121,
12321 and 98989 are all palindromic integers. The largest palindromic integer made from
the product of two 2-digit numbers is 9009 = 91 Ã— 99. Write a function sdsu-palindome that
takes one argument, an integer. The integer indicates the number of digits we are interesting
in. So (sdsu-palindrome 2) returns the largest palindromic integer made from the product
of two 2-digit numbers and (sdsu-palindrome 3) returns the largest palindromic integer
made from the product of two 3-digit numbers."

(defn palindrome
  [x]
   (= (seq (str x)) (reverse (seq (str x)))))


(defn sdsu-palindrome
  [i]
   (reduce max (filter
                palindrome (for [x (range (int (Math/pow 10 (dec i))) (int (Math/pow 10 i)))
                                 y (range (int (Math/pow 10 (dec i))) (int (Math/pow 10 i)))]
                             (* x y)))))







"The Fibonacci sequence is generated by adding the previous two terms in the sequence.
We will start the sequence with 1 and 2. So the first ten elements are 1, 2, 3, 5, 8, 13, 21,
34, 55, 89. Write a function sdsu-fibonacci-even that takes one argument N. The function
returns the sum of all the even-valued terms in the Fibonacci sequence that are less then
or equal to N."

(defn fibonacci
  [N]
  (loop [first 0 second 1 series [0] N N]
    (if (<= second N)
        (recur second (+ first second) (conj series second) N)
        series)))

(defn sdsu-fibonacci-even
  [N]
  (reduce + (filter even? (fibonacci N))))







"DNA can be represented as a string containing the characters A, C, G and T. These letters
represent the four nucleobases adenine (A), cytosine (C), guanine (G), and thymine (T).
An example of a DNA string is 'ATGCTTCAGAAAGGTCTTACG'. Write a functions sdsu-dna-
count that takes one argument, a DNA string, and returns a map that indicate the number
of times each of the four characters appears in the DNA string."

(defn dna-count
  [x a t g c]
  (if (= (count x) 0)
    {:A a, :T t, :G g, :C c}
    (if (or (= (subs x 0 1) "A") (= (subs x 0 1) "T") (= (subs x 0 1) "G") (= (subs x 0 1) "C"))
      (if (or (= (subs x 0 1) "A") (= (subs x 0 1) "T"))
        (if (= (subs x 0 1) "A")
          (dna-count (subs x 1 (count x)) (inc a) t g c)
          (dna-count (subs x 1 (count x)) a (inc t) g c))
        (if (or (= (subs x 0 1) "G") (= (subs x 0 1) "C"))
          (if (= (subs x 0 1) "G")
            (dna-count (subs x 1 (count x)) a t (inc g) c)
            (dna-count (subs x 1 (count x)) a t g (inc c)))))
      :not-a-dna-string)))

(defn sdsu-dna-count
  [x]
  (dna-count x 0 0 0 0))







"Write a function, sdsu-digits, with two arguments, n and b. The first argument, n, is a nonnegative
number in base 10. The second argument, b, is a positive integer also in based
ten. Sdsu-digits converts the first number from base 10 to base b. The return value is a collection
of the digits not as one number or as a single string. Digits should be represented
with their integer values. For 15 would be [1 5] in base 10, [1 1 1 1] in base 2 and [15] in
base 16."

(defn digit
  [n b a]
  (loop [n n b b a a]
    (if (or (< n 0) (< n 0) (= b 0))
      :illegal-values
      (if (< n b)
        (reverse (conj a n))
        (if (>= n b)
          (recur (quot n b) b (conj a (rem n b))))))))


(defn sdsu-digits
  [n b]
  (digit n b []))







"Write a function sdsu-roman-numeral has one argument, an integer smaller than 4000. The
function returns the corresponding roman numeral in uppercase."

(defn roman-numeral
  [n a]
  (if (> n 0)
    (if (> n 4000)
      :number-greater-than-4000
      (if (>= n 1000)
        (roman-numeral (- n 1000) (str a "M"))
        (if (>= n 500)
          (if (>= n 900)
            (roman-numeral (- n 900) (str a "CM"))
            (roman-numeral (- n 500) (str a "D")))
          (if (>= n 100)
            (if (>= n 400)
              (roman-numeral (- n 400) (str a "CD"))
              (roman-numeral (- n 100) (str a "C")))
            (if (>= n 50)
              (if (>= n 90)
                (roman-numeral (- n 90) (str a "XC"))
                (roman-numeral (- n 50) (str a "L")))
              (if (>= n 10)
                (if (>= n 40)
                  (roman-numeral (- n 40) (str a "XL"))
                  (roman-numeral (- n 10) (str a "X")))
                (if (>= n 5)
                  (if (= n 9)
                    (roman-numeral (- n 9) (str a "IX"))
                    (roman-numeral (- n 5) (str a "V")))
                  (if (= n 4)
                    (roman-numeral (- n 4) (str a "IV"))
                    (roman-numeral (- n 1) (str a "I"))))))))))
    (if (= a "")
      :number-cant-be-smaller-or-equal-to-zero
      a)))


(defn sdsu-roman-numeral
  [n]
  (roman-numeral n ""))
